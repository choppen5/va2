/*
 * Project: DDS Project
 * Author : Charles Oppenheimer
 * Date   : Jun 25 2002 17:29
 * File auto-generated by Database Design Studio V1.09.2
 * Syntax : isql /Uuser /Ppassword /Sserver -i\path\filename.sql
*/
/*
 * Target DBMS: 'MSSQL'
*/
 
 
set nocount      on
set dateformat   dmy
 
/*
 * select the working database
*/
use master
 
go
 
/*
 * create a local variable for storing the current date
*/
declare @dttm varchar(55)
select  @dttm=convert(varchar,getdate(),3)
raiserror('beginning batch build at %s ....',1,1,@dttm) with nowait
 
/*
 * if the database already exists, it will be dropped
*/
if exists (select * from sysdatabases where name='vadmin21')
    drop database vadmin21
 
go
 
checkpoint
 
go
 
/*
 * if SQL 4.2, 6.0 or 6.5 create the new database in the selected devices
 * if version 7.0 create the database using the default size with autogrow
*/
if (charindex('4.2', @@version) > 0 or
    charindex('6.0', @@version) > 0 or
    charindex('6.5', @@version) > 0)
    create database vadmin21
        on master = 3
else
    create database vadmin21
 
go
 
checkpoint
 
go
 
/*
 * select the working database
*/
use vadmin21
 
go
 
/*
 * ensure the database was created successfully
*/
if db_name() = 'vadmin21'
    raiserror('''vadmin21'' database created, and context now in use.',1,1)
else
    raiserror('error in batch file, ''use vadmin21'' failed!  killing the spid now.',22,127) with log
 
go
 
execute sp_dboption 'vadmin21' ,'trunc. log on chkpt.' ,'true'
 
go
 
/*
 * Table               : errorevent
 * Description         : popultated as result of error deff conditions or  - via XML interface or ODBC
 * errorevent_id       : 
 * type                : 
 * event_sub_type      : 
 * event_level         : 
 * event_time          : 
 * event_string        : 
 * status              : 
 * error_defs_id       : 
 * cc_alias            : 
 * sv_name             : 
 * sft_elmnt_id        : 
 * processed           : 
 * reactionfired       : 
 * host                : host where error occured 
*/
create table errorevent (
    errorevent_id   int not null,
    type            char(50) null,
    event_sub_type  char(50) null,
    event_level     char(20) null,
    event_time      char(50) null,
    event_string    char(254) null,
    status          char(10) null,
    error_defs_id   int null,
    cc_alias        char(50) null,
    sv_name         char(50) null,
    sft_elmnt_id    int null,
    processed       char(1) null,
    reactionfired   char(1) null,
    host            char(50) null,
constraint pk_errorevent primary key clustered (errorevent_id))
 
go
 
 
/*
 * Table               : notification_rule
 * Description         : rules for monitoring error event table - conditions will be "anded" - will send messages to communication server
 * note_rule_id        : shorted to avaoid trucation 
 * name                : user name for notification rule 
 * message             : not a condition 
 * notify_all          : 
 * incl_ev_string      : 
 * inc_ev_level        : 
 * inc_ev_subtype      : 
 * type                : 
 * status              : 
 * active              : 
 * ev_sft_elmnt_id     : anded foriegn key to application table 
 * ev_event_sub_type   : anded 
 * ev_event_level      : anded 
 * ev_event_time       : anded 
 * ev_event_string     : anded - regexp 
 * ev_type             : 
*/
create table notification_rule (
    note_rule_id    char(10) not null,
    name            char(30) null,
    message         char(50) not null,
    notify_all      char(1) null,
    incl_ev_string  char(1) null,
    inc_ev_level    char(50) null,
    inc_ev_subtype  char(1) null,
    type            char(50) null,
    status          char(10) null,
    active          char(1) null,
    ev_sft_elmnt_id int null,
    ev_event_sub_type char(50) null,
    ev_event_level  int null,
    ev_event_time   char(50) null,
    ev_event_string char(254) null,
    ev_type         char(20) null,
constraint pk_notification_rule primary key clustered (note_rule_id))
 
go
 
 
/*
 * Table               : host
 * Description         : machine specific info
 * host_id             : 
 * hostname            : 
 * ipaddress           : 
 * os                  : 
 * status              : 
*/
create table host (
    host_id         char(10) not null,
    hostname        char(50) null,
    ipaddress       char(50) null,
    os              char(50) null,
    status          char(20) null,
constraint pk_host primary key clustered (host_id))
 
go
 
 
/*
 * Table               : schedule
 * Description         : first draft
 * schedule_id         : 
 * schedule_every      : overides all hour minutes specs 
 * monday              : 
 * tuesday             : 
 * wednesday           : 
 * thursday            : 
 * friday              : 
 * saturday            : 
 * sunday              : 
 * every_day           : overides daily columns 
 * hour_start          : 24 
 * minute_start        : 60 
 * hour_end            : 60 
 * minute_end          : 
 * every_hour          : overides hour/minutes 
 * schd_name           : 
 * start_time          : 
 * end_time            : 
*/
create table schedule (
    schedule_id     int not null,
    schedule_every  char(1) null,
    monday          char(1) null,
    tuesday         char(1) null,
    wednesday       char(1) null,
    thursday        char(1) null,
    friday          char(1) null,
    saturday        char(1) null,
    sunday          char(1) null,
    every_day       char(1) null,
    hour_start      char(2) null,
    minute_start    char(2) null,
    hour_end        char(2) null,
    minute_end      char(2) null,
    every_hour      char(1) null,
    schd_name       char(50) null,
    start_time      datetime null,
    end_time        datetime null,
constraint pk_schedule primary key clustered (schedule_id))
 
go
 
 
/*
 * Table               : comunicationserver
 * Description         : 
 * com_server_id       : truncated from comunicationserver_id 
 * smtp_server         : 
 * webserver           : for future use 
 * paging_server       : futureuse 
 * modemnumber         : future use 
 * type                : 
 * active              : 
 * name                : 
*/
create table comunicationserver (
    com_server_id   char(10) not null,
    smtp_server     char(50) null,
    webserver       char(50) null,
    paging_server   char(50) null,
    modemnumber     char(50) null,
    type            char(20) null,
    active          char(1) null,
    name            char(50) null,
constraint pk_comunicationserver primary key clustered (com_server_id))
 
go
 
 
/*
 * Table               : system_msg
 * Description         : 
 * system_msg_id       : 
 * type                : 
 * message             : 
 * host                : 
 * app_server          : 
 * processesed         : 
*/
create table system_msg (
    system_msg_id   int not null,
    type            char(10) null,
    message         char(50) null,
    host            char(50) null,
    app_server      char(50) null,
    processesed     char(1) null,
constraint pk_system_msg primary key clustered (system_msg_id))
 
go
 
 
/*
 * Table               : analysis_rule
 * Description         : deffinition for a executible system check
 * analysis_rule_id    : 
 * type                : 
 * rule_def            : definition -sql, wmi, perl, etc 
 * error               : error message displayed if rule unexecutible 
 * name                : 
 * sf_error_deff_id    : 
 * active              : 
 * execution_interval  : 
 * description         : 
*/
create table analysis_rule (
    analysis_rule_id int not null,
    type            char(10) null,
    rule_def        varchar(4000) null,
    error           char(254) null,
    name            char(100) null,
    sf_error_deff_id int null,
    active          char(1) null,
    execution_interval int null,
    description     char(100) null,
constraint pk_analysis_rule primary key clustered (analysis_rule_id))
 
go
 
 
/*
 * Table               : reaction
 * Description         : deffinition for a executible system check
 * reaction_id         : 
 * type                : 
 * rule_def            : definition -sql, wmi, perl, etc 
 * error               : error message displayed if rule unexecutible 
 * name                : 
 * host_specific       : if true, execute reaction on host of error,otherwise central 
 * active              : 
*/
create table reaction (
    reaction_id     int not null,
    type            char(10) null,
    rule_def        varchar(2000) null,
    error           char(100) null,
    name            char(20) null,
    host_specific   char(50) null,
    active          char(1) null,
constraint pk_reaction primary key clustered (reaction_id))
 
go
 
 
/*
 * Table               : collector
 * Description         : script/sql to collect non internal statistics
 * collector_id        : 
 * type                : 
 * rule_def            : definition -sql, wmi, perl, etc 
 * error               : error message displayed if rule unexecutible 
 * name                : 
 * odbc                : 
 * active              : 
 * sft_elmnt_id        : 
 * host_id             : host a collector is associated with 
 * description         : description of the statistic 
 * execution_interval  : 
 * max_records         : 
*/
create table collector (
    collector_id    int not null,
    type            char(10) null,
    rule_def        varchar(4000) null,
    error           char(254) null,
    name            char(100) null,
    odbc            char(50) null,
    active          char(1) null,
    sft_elmnt_id    int null,
    host_id         int null,
    description     char(100) null,
    execution_interval int null,
    max_records     int null,
constraint pk_collector primary key clustered (collector_id))
 
go
 
 
/*
 * Table               : sft_mng_sys
 * Description         : 
 * sft_mng_sys_id      : 
 * name                : 
 * status              : 
 * state               : 
*/
create table sft_mng_sys (
    sft_mng_sys_id  int not null,
    name            char(50) null,
    status          char(20) null,
    state           char(20) null,
constraint pk_sft_mng_sys primary key clustered (sft_mng_sys_id))
 
go
 
 
/*
 * Table               : sft_error_defs
 * Description         : string errors and messages will be configured per component/appserver
 * error_defs_id       : 
 * ev_type             : 
 * ev_level            : 
 * ev_time             : 
 * search_string       : 
 * ev_sub_type         : 
 * host                : 
 * name                : Name of Error Deffinition 
 * sv_name             : 
 * cc_alias            : 
 * sf_elmnt_id         : 
 * active              : 
*/
create table sft_error_defs (
    error_defs_id   int not null,
    ev_type         char(50) null,
    ev_level        char(50) null,
    ev_time         char(50) null,
    search_string   char(254) null,
    ev_sub_type     char(50) null,
    host            char(254) null,
    name            char(50) null,
    sv_name         char(50) null,
    cc_alias        char(50) null,
    sf_elmnt_id     char(50) null,
    active          char(1) null,
constraint pk_sft_error_defs primary key clustered (error_defs_id))
 
go
 
 
/*
 * Table               : server_task
 * Description         : related to sft_elment (for all tasks per app server) or components and monitored_comps , (all task per component)
 * server_task_id      : 
 * sv_name             : 
 * cc_alias            : 
 * tk_taskid           : 
 * tk_pid              : 
 * tk_disp_runstate    : 
 * cc_runmode          : 
 * tk_start_time       : 
 * tk_end_time         : 
 * tk_status           : 
 * cg_alias            : 
 * sft_elmnt_id        : 
 * sft_elmnt_comp_id   : 
*/
create table server_task (
    server_task_id  int not null,
    sv_name         char(100) null,
    cc_alias        char(100) null,
    tk_taskid       int null,
    tk_pid          int null,
    tk_disp_runstate char(100) null,
    cc_runmode      char(100) null,
    tk_start_time   char(50) null,
    tk_end_time     char(50) null,
    tk_status       char(254) null,
    cg_alias        char(100) null,
    sft_elmnt_id    int null,
    sft_elmnt_comp_id int null,
constraint pk_server_task primary key clustered (server_task_id))
 
go
 
 
/*
 * Table               : monitored_comps
 * Description         : represents all components per app server being monitored
 * monitored_comps_id  : 
 * sv_name             : 
 * cp_max_mts          : 
 * cc_name             : use this key to show running components per component deff 
 * ct_alias            : 
 * cg_name             : 
 * cc_runmode          : 
 * cp_disp_run_state   : 
 * cp_num_run          : 
 * cp_max_tas          : 
 * cp_actv_mt          : 
 * cc_alias            : 
 * cp_start_time       : 
 * cp_end_time         : 
 * cp_status           : 
 * sft_elmnt_id        : 
 * sft_elmnt_comp_id   : 
*/
create table monitored_comps (
    monitored_comps_id int not null,
    sv_name         char(50) null,
    cp_max_mts      int null,
    cc_name         char(50) null,
    ct_alias        char(50) null,
    cg_name         char(50) null,
    cc_runmode      char(50) null,
    cp_disp_run_state char(50) null,
    cp_num_run      int null,
    cp_max_tas      int null,
    cp_actv_mt      int null,
    cc_alias        char(50) null,
    cp_start_time   char(50) null,
    cp_end_time     char(50) null,
    cp_status       char(50) null,
    sft_elmnt_id    int null,
    sft_elmnt_comp_id char(50) null,
constraint pk_monitored_comps primary key clustered (monitored_comps_id))
 
go
 
 
/*
 * Table               : processes
 * Description         : related to the app server via sft_enlmnt_id, aslo to component or task via cc_name or ct_name,respectively
 * process_id          : 
 * sv_name             : 
 * task_id             : 
 * pid                 : 
 * cc_alias            : 
 * cc_name             : 
 * host                : 
 * state               : 
 * process             : 
 * cpu                 : 
 * cpu_time            : 
 * memory              : 
 * pagefaults          : 
 * virtualmem          : 
 * priority            : 
 * threads             : 
 * sft_elmnt_id        : 
 * sft_elmnt_comp_id   : 
*/
create table processes (
    process_id      int not null,
    sv_name         char(50) null,
    task_id         char(10) null,
    pid             int null,
    cc_alias        char(50) null,
    cc_name         char(100) null,
    host            char(50) null,
    state           char(50) null,
    process         char(50) null,
    cpu             float(10) null,
    cpu_time        char(10) null,
    memory          int null,
    pagefaults      int null,
    virtualmem      int null,
    priority        char(50) null,
    threads         int null,
    sft_elmnt_id    int null,
    sft_elmnt_comp_id int null,
constraint pk_processes primary key clustered (process_id))
 
go
 
 
/*
 * Table               : components
 * Description         : will contain all Siebel default components, plus user definable components
 * components_id       : 
 * description         : 
 * log_analyze         : 
 * log_monitor         : 
 * sft_elmnt_id        : 
 * cc_alias            : 
*/
create table components (
    components_id   int not null,
    description     char(100) null,
    log_analyze     char(1) null,
    log_monitor     char(1) null,
    sft_elmnt_id    int null,
    cc_alias        char(80) not null,
constraint pk_components primary key clustered (components_id))
 
go
 
 
/*
 * Table               : analysis_err
 * Description         : If the anlaysis object returns false, the error defined here will be inserted into error event table
 * analysis_err_id     : 
 * evt_type            : 
 * evt_event_sub_type  : 
 * evt_event_level     : 
 * evt_event_time      : 
 * evt_event_string    : 
 * evt_status          : 
 * evt_cc_alias        : 
 * evt_sv_name         : 
 * evt_sft_elmnt_id    : 
 * evt_host            : 
 * name                : 
*/
create table analysis_err (
    analysis_err_id int not null,
    evt_type        char(10) null,
    evt_event_sub_type char(50) null,
    evt_event_level int null,
    evt_event_time  char(50) null,
    evt_event_string char(254) null,
    evt_status      char(50) null,
    evt_cc_alias    char(50) null,
    evt_sv_name     char(50) null,
    evt_sft_elmnt_id int null,
    evt_host        char(254) null,
    name            char(50) null,
constraint pk_analysis_err primary key clustered (analysis_err_id))
 
go
 
 
/*
 * Table               : tableids
 * Description         : 
 * table_name          : 
 * id                  : 
*/
create table tableids (
    table_name      char(50) not null,
    id              int not null,
constraint pk_tableids primary key clustered (table_name))
 
go
 
 
/*
 * Table               : data_source
 * Description         : 
 * data_source_id      : 
 * name                : 
 * username            : 
 * password            : 
 * host                : 
 * alias               : alias name for ODBC 
*/
create table data_source (
    data_source_id  int not null,
    name            char(50) null,
    username        char(50) null,
    password        char(50) null,
    host            char(50) null,
    alias           char(50) not null,
constraint pk_data_source primary key clustered (data_source_id, alias))
 
go
 
 
/*
 * Table               : administrators
 * Description         : persons with email address 
 * administrators_id   : 
 * first_name          : 
 * last_name           : 
 * password            : 
 * email               : 
 * phone               : 
 * pager               : 
 * default_admin       : 
 * user_name           : 
 * schedule_id         : (Foreign Key
 *                        references SCHEDULE.schedule_id)
*/
create table administrators (
    administrators_id char(10) not null,
    first_name      char(50) null,
    last_name       char(50) null,
    password        char(50) null,
    email           char(70) null,
    phone           char(50) null,
    pager           char(50) null,
    default_admin   char(1) null,
    user_name       char(50) null,
    schedule_id     int null,
constraint pk_administrators primary key clustered (administrators_id),
constraint fk_administrators foreign key (schedule_id)
    references schedule (schedule_id))
 
go
 
 
/*
 * Table               : errorexceptions
 * Description         : ignore errors based on time/date or string
 * errorexceptions_id  : 
 * errorexception      : 
 * time_exemption      : ignore errors before this date 
 * err_type_exept      : 
 * note_rule_id        : shorted to avaoid trucation (Foreign Key
 *                        references NOTIFICATION_RULE.note_rule_id)
*/
create table errorexceptions (
    errorexceptions_id char(10) not null,
    errorexception  char(254) null,
    time_exemption  datetime null,
    err_type_exept  char(10) null,
    note_rule_id    char(10) null,
constraint pk_errorexceptions primary key clustered (errorexceptions_id),
constraint fk_errorexceptions foreign key (note_rule_id)
    references notification_rule (note_rule_id))
 
go
 
 
/*
 * Table               : host_os_stats
 * Description         : machine specific info
 * db_id               : 
 * running_since       : 
 * status              : 
 * memory_consuption   : 
 * cpu_utilization     : 
 * time_stamp          : 
 * host_id             : (Foreign Key
 *                        references HOST.host_id)
*/
create table host_os_stats (
    db_id           char(10) not null,
    running_since   datetime null,
    status          char(10) null,
    memory_consuption char(50) null,
    cpu_utilization char(50) null,
    time_stamp      datetime null,
    host_id         char(10) null,
constraint pk_host_os_stats primary key clustered (db_id),
constraint fk_host_os_stats foreign key (host_id)
    references host (host_id))
 
go
 
 
/*
 * Table               : com_admin
 * Description         : 
 * com_server_id       : truncated from comunicationserver_id (Foreign Key
 *                        references COMUNICATIONSERVER.com_server_id)
 * administrators_id   : (Foreign Key
 *                        references ADMINISTRATORS.administrators_id)
*/
create table com_admin (
    com_server_id   char(10) not null,
    administrators_id char(10) not null,
constraint pk_com_admin primary key clustered (com_server_id, administrators_id),
constraint fk_com_admin1 foreign key (com_server_id)
    references comunicationserver (com_server_id),
constraint fk_com_admin2 foreign key (administrators_id)
    references administrators (administrators_id))
 
go
 
 
/*
 * Table               : stat_vals
 * Description         : values populated as result of stat_defs
 * stat_vals_id        : 
 * val                 : 
 * time_stmp           : 
 * collector_id        : (Foreign Key
 *                        references COLLECTOR.collector_id)
*/
create table stat_vals (
    stat_vals_id    int not null,
    val             float(20) not null,
    time_stmp       datetime not null,
    collector_id    int null,
constraint pk_stat_vals primary key clustered (stat_vals_id),
constraint fk_stat_vals foreign key (collector_id)
    references collector (collector_id))
 
go
 
 
/*
 * Table               : sft_elmnt
 * Description         : 
 * sft_elmnt_id        : 
 * type                : 
 * description         : 
 * name                : 
 * os                  : 
 * host                : 
 * installdir          : 
 * status              : 
 * exe                 : 
 * service_name        : 
 * parent_elmnt_id     : 
 * logdir              : 
 * sft_mng_sys_id      : (Foreign Key
 *                        references SFT_MNG_SYS.sft_mng_sys_id)
*/
create table sft_elmnt (
    sft_elmnt_id    int not null,
    type            char(20) null,
    description     char(50) null,
    name            char(50) null,
    os              char(20) null,
    host            char(50) null,
    installdir      char(254) null,
    status          char(20) null,
    exe             char(50) null,
    service_name    char(50) null,
    parent_elmnt_id int null,
    logdir          char(254) null,
    sft_mng_sys_id  int null,
constraint pk_sft_elmnt primary key clustered (sft_elmnt_id),
constraint fk_sft_elmnt foreign key (sft_mng_sys_id)
    references sft_mng_sys (sft_mng_sys_id))
 
go
 
 
/*
 * Table               : sft_elmnt_comp
 * Description         : key value description of component
 * sft_elmnt_comp_id   : 
 * type                : 
 * elmnt_key           : 
 * elmnt_value         : 
 * status              : 
 * sft_elmnt_id        : (Foreign Key
 *                        references SFT_ELMNT.sft_elmnt_id)
*/
create table sft_elmnt_comp (
    sft_elmnt_comp_id int not null,
    type            char(20) null,
    elmnt_key       char(50) not null,
    elmnt_value     char(254) not null,
    status          char(20) null,
    sft_elmnt_id    int null,
constraint pk_sft_elmnt_comp primary key clustered (sft_elmnt_comp_id),
constraint fk_sft_elmnt_comp foreign key (sft_elmnt_id)
    references sft_elmnt (sft_elmnt_id))
 
go
 
 
/*
 * Table               : comp_errdef
 * Description         : 
 * components_id       : (Foreign Key
 *                        references COMPONENTS.components_id)
 * error_defs_id       : (Foreign Key
 *                        references SFT_ERROR_DEFS.error_defs_id)
*/
create table comp_errdef (
    components_id   int not null,
    error_defs_id   int not null,
constraint pk_comp_errdef primary key clustered (components_id, error_defs_id),
constraint fk_comp_errdef1 foreign key (components_id)
    references components (components_id),
constraint fk_comp_errdef2 foreign key (error_defs_id)
    references sft_error_defs (error_defs_id))
 
go
 
 
/*
 * Table               : com_srvr_vals
 * Description         : key value description of component
 * com_srvr_vals_id    : 
 * type                : 
 * elmnt_key           : 
 * elmnt_value         : 
 * status              : 
 * com_server_id       : truncated from comunicationserver_id (Foreign Key
 *                        references COMUNICATIONSERVER.com_server_id)
*/
create table com_srvr_vals (
    com_srvr_vals_id int not null,
    type            char(20) null,
    elmnt_key       char(50) not null,
    elmnt_value     char(254) not null,
    status          char(20) null,
    com_server_id   char(10) null,
constraint pk_com_srvr_vals primary key clustered (com_srvr_vals_id),
constraint fk_com_srvr_vals foreign key (com_server_id)
    references comunicationserver (com_server_id))
 
go
 
 
/*
 * Table               : notification_reaction
 * Description         : 
 * note_rule_id        : shorted to avaoid trucation (Foreign Key
 *                        references NOTIFICATION_RULE.note_rule_id)
 * reaction_id         : (Foreign Key
 *                        references REACTION.reaction_id)
*/
create table notification_reaction (
    note_rule_id    char(10) not null,
    reaction_id     int not null,
constraint pk_notification_reaction primary key clustered (note_rule_id, reaction_id),
constraint fk_notification_reaction1 foreign key (note_rule_id)
    references notification_rule (note_rule_id),
constraint fk_notification_reaction2 foreign key (reaction_id)
    references reaction (reaction_id))
 
go
 
 
/*
 * Table               : analysis_errdef
 * Description         : 
 * analysis_rule_id    : (Foreign Key
 *                        references ANALYSIS_RULE.analysis_rule_id)
 * error_defs_id       : (Foreign Key
 *                        references SFT_ERROR_DEFS.error_defs_id)
*/
create table analysis_errdef (
    analysis_rule_id int not null,
    error_defs_id   int not null,
constraint pk_analysis_errdef primary key clustered (analysis_rule_id, error_defs_id),
constraint fk_analysis_errdef1 foreign key (analysis_rule_id)
    references analysis_rule (analysis_rule_id),
constraint fk_analysis_errdef2 foreign key (error_defs_id)
    references sft_error_defs (error_defs_id))
 
go
 
 
/*
 * Table               : sft_err_deff
 * Description         : 
 * sft_elmnt_id        : (Foreign Key
 *                        references SFT_ELMNT.sft_elmnt_id)
 * error_defs_id       : (Foreign Key
 *                        references SFT_ERROR_DEFS.error_defs_id)
*/
create table sft_err_deff (
    sft_elmnt_id    int not null,
    error_defs_id   int not null,
constraint pk_sft_err_deff primary key clustered (sft_elmnt_id, error_defs_id),
constraint fk_sft_err_deff1 foreign key (sft_elmnt_id)
    references sft_elmnt (sft_elmnt_id),
constraint fk_sft_err_deff2 foreign key (error_defs_id)
    references sft_error_defs (error_defs_id))
 
go
 


insert system_msg (system_msg_id,type,message) values (1,1,60)
go

insert sft_error_defs (error_defs_id,name,search_string,ev_level,ev_type,ev_sub_type) values (1,'Component Reached max tasks','','','Components Maxed','')
go

insert sft_error_defs (error_defs_id,name,search_string,ev_level,ev_type,ev_sub_type) values (2,'Transaction Backlog','','','Transaction Backlog','')
go

insert sft_error_defs (error_defs_id,name,search_string,ev_level,ev_type,ev_sub_type) values (3,'Process or Component exited with Error','Process exited with error','','','')
go


insert notification_rule (note_rule_id,name, message,notify_all,active,type,ev_event_sub_type,ev_event_level,ev_event_string) values (1,'Siebel Component Maxed','1 or More Siebel Component has reached Max Tasks','N','Y','Components Maxed','','','')
go

insert notification_rule (note_rule_id,name, message,notify_all,active,type,ev_event_sub_type,ev_event_level,ev_event_string) values (2,'Transaction Backlog','Warning!  Transaction Backlog detected','N','Y','Transacton Backlog','','','')
go

insert notification_rule (note_rule_id,name, message,notify_all,active,type,ev_event_sub_type,ev_event_level,ev_event_string) values (3,'Siebel Proc Exited with Error!','Siebel Process exited with Error','N','Y','Process exited with error','','','')
go


/*INSERT DEFAULT ANALYSIS RULES*/

insert into analysis_rule (analysis_rule_id,type,name,description,active,execution_interval,rule_def) values (1,'Perl','Component Reached max tasks','Finds any components that have reached MAX tasks for a component','Y','1','use siebsrvobj;

my $href;     	# refrence to a hash
my @error;   	# list of task errors   

my @allcomps; 	#  array of server task records


my $entobj = siebsrvobj->newobj($datasession,$debug,''siebel'');  	#initialize the enterprise object
@allcomps = $entobj->entcomps();  				#get array of all server tasks


foreach  $href (0..$#allcomps) {  				#loop through the tasks
		
     my $errstring = "COMPONENT: $allcomps[$href]{cc_alias} HAS RUNNING TASKS = $allcomps[$href]{cp_num_run}\n";  	
     print $errstring;  							 	                 #for debugging...

     #look for the string "Exited with error".... if there is an error, add a string to the @error array, which will be emailed...eventually
      if ($allcomps[$href]{cp_num_run} == $allcomps[$href]{cp_max_tas}) {push @error, "WARNING!! THE FOLLOWING COMPONENT HAS MAXED OUT ON ALLOWABLE TASKS: $errstring\n"}		  
  }

if (@error == 0) { #the number of errors == 0, so $retval = 1 
	$retval = 1;
	#errormessage overide = @errors
}')
go


insert into analysis_rule (analysis_rule_id,type,name,description,active,execution_interval,rule_def) values (2,'Perl','Txn backlog','Checks whether there is a transaction backlog','Y','1440','require sqlanalyze;

my $sql = "select MAX(TXN_ID) \"MAX\" from S_DOCK_TXN_LOG";

my $maxtxn = sqlanalyze->returnsinglevalue($sql, $datasource{siebeldata},"MAX");
print "MAX TXN = $maxtxn\n";

$sql = <<ENDSQL;
select LAST_TXN_NUM "LAST" from S_DOCK_STATUS st, S_NODE n
where st.NODE_ID=n.ROW_ID and 
n.NODE_TYPE_CD="TXNPROC" and
st.LOCAL_FLG="Y" and 
st.TYPE="ROUTE" and
(n.EFF_END_DT IS NULL OR n.EFF_END_DT > getdate())
ENDSQL

my $lastroutedtxn = sqlanalyze->returnsinglevalue($sql, $datasource{siebeldata},"LAST");
print "LAST ROUTED TXN = $lastroutedtxn\n";

unless ($lastroutedtxn > $maxtxn) {$retval = 1}  #if last routed txn is > than the max txn, changes will not be routed to mobile clients
')
go


/*ATTACH ERROR DEFINITIONS TO ANALYSIS RULES*/


insert into analysis_errdef(analysis_rule_id, error_defs_id) values (1,1)
go

insert into analysis_errdef(analysis_rule_id, error_defs_id) values (2,2)
go

/*ATTACH ERROR DEFINITIONS TO ANALYSIS RULES*/

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (1,'Perl','60','Central Server Uptime','Number of hours that Central Server has been running','Y','
$retval = Win32::GetTickCount() / 3600000;')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (2,'Perl','1440','Number of Opportunities','Number of Opportunities','Y','
use sqlanalyze;
$retval = sqlanalyze->sqlcount("select count(*)  from S_OPTY", $datasource{siebeldata});')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (3,'Perl','1440','Number of Accounts','Number of Accounts','Y','
use sqlanalyze;
$retval = sqlanalyze->sqlcount("select count(*) from S_ORG_EXT", $datasource{siebeldata});')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (4,'Perl','1440','Number of Activities','Number of Activities','Y','
use sqlanalyze;
$retval = sqlanalyze->sqlcount("select count(*) from S_EVT_ACT", $datasource{siebeldata});')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (5,'Perl','1440','Number of Contacts','Number of Contacts','Y','
use sqlanalyze;
$retval = sqlanalyze->sqlcount("select count(*) from S_CONTACT", $datasource{siebeldata});')
GO


insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (6,'Perl','10080','Number of Expired Workflow Rules','Count of total number of expired workflow rules - SQL Server','Y','
use sqlanalyze;

my $sql = <<SQLEND;
select count(*) 
from s_escl_rule
where expire_dt is not null and expire_dt <= getdate() 
SQLEND

$retval = sqlanalyze->sqlcount($sql, $datasource{siebeldata});')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (7,'Perl','1440','S_ESCL_REC backlog','Records in S_ESCL_REQ for expired workflow rules','Y','
use sqlanalyze;

my $sql = <<SQLEND;
select count(*) from s_escl_req where rule_id in (select row_id from s_escl_rule where expire_dt is not null and expire_dt <= getdate()) 
SQLEND

$retval = sqlanalyze->sqlcount($sql, $datasource{siebeldata});
')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (8,'Perl','1440','Number of Records in S_DOC_TXN_LOG','High value indicates a backlog in Transactions being processed for Mobile Clients','Y','
use sqlanalyze;
my $sql = "select count(*) from S_DOCK_TXN_LOG";
$retval = sqlanalyze->sqlcount($sql, $datasource{siebeldata});
')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (9,'Perl','1440','Number of DB users -  SQL Server','Number of system process','Y','
use sqlanalyze;

my $sql = "select count(*) from  master.dbo.sysprocesses";

$retval = sqlanalyze->sqlcount($datasession, $datasource{siebeldata});
')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (10,'Perl','30','Number of DB users -  SQL Server','MB Count of SQL Server size','Y','

require sqlanalyze; 

my $sql = "sp_spaceused"; #sql server stored procedure
my $dbsize = sqlanalyze->returnsinglevalue($sql, $datasource{siebeldata},"database_size");

if ($dbsize =~ /(\d+\.\d+) MB/) {
	$retval = $1;	#$1 is the captured db size from a string
')
GO

insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (11,'Perl','10080','DB Size - in MBs - Vadmin21','MB Size of SQL Server  - Vadmin21 db','Y','
require sqlanalyze; 

my $sql = "sp_spaceused"; #sql server stored procedure
my $dbsize = sqlanalyze->returnsinglevalue($sql, $datasession,"database_size"); #$datasession is the active connection to the vadmindb

if ($dbsize =~ /(\d+\.\d+) MB/) {
	$retval = $1;	#$1 is the captured db size from a string
}
')
GO


insert collector(collector_id,type,execution_interval,name,description,active,rule_def) values (12,'Perl','10800','DB Size - in MBs - SiebelDB','MB Size of SQL Server  - Siebel db','Y','

require sqlanalyze; 

my $sql = "sp_spaceused"; #sql server stored procedure
my $dbsize = sqlanalyze->returnsinglevalue($sql, $datasource{siebeldata},"database_size");

if ($dbsize =~ /(\d+\.\d+) MB/) {
	$retval = $1;	#$1 is the captured db size from a string
}
')
go

